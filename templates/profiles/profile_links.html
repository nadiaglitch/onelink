{% extends "base.html" %}
{% load static %}
{% block content %}
<style>
.editable-text {
  border: none; background: transparent; padding: 0; margin: 0; width: 100%;
  font: inherit; color: inherit; outline: none;
}
.editable-text:focus { outline: 2px dashed #9ca3af; outline-offset: 2px; }
.editable-area[contenteditable="true"]:focus { outline: 2px dashed #9ca3af; outline-offset: 2px; }

.profile-shell { max-width: 520px; margin: 0 auto; padding: 2rem 1rem 6rem; text-align: center; }
.avatar-wrap { width: 128px; height: 128px; margin: 0 auto 1rem; position: relative; }
.avatar-wrap img { width: 128px; height: 128px; border-radius: 9999px; object-fit: cover; }
.avatar-wrap input[type="file"] { position: absolute; inset: 0; opacity: 0; cursor: pointer; }

.handle { color: #6b7280; font-size: 0.95rem; }
.bio { color: #374151; margin-top: .5rem; }

.links { display: grid; gap: 10px; margin-top: 1.5rem; }
.link-card {
  border: 1px solid #e5e7eb; border-radius: 12px; padding: 12px 14px;
  display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center;
}
.link-guts { display: grid; gap: 6px; text-align: left; }
.link-title { font-weight: 600; }
.link-url { font-size: .9rem; color: #6b7280; word-break: break-all; }
.link-actions { display: flex; gap: 8px; align-items: center; }
.icon-btn { border: 1px solid #d1d5db; background: white; padding: 6px 10px; border-radius: 8px; cursor: pointer; }
.icon-btn[disabled] { opacity: .5; cursor: not-allowed; }

.drag { cursor: grab; user-select: none; font-size: 18px; }
.drag:active { cursor: grabbing; }
.hidden { display: none; }

.text-red-500 { color: #ef4444; }
.text-sm { font-size: 0.875rem; }
.text-center { text-align: center; }
.mt-1 { margin-top: 0.25rem; }

/* Placeholder for empty contenteditable bios */
.editable-area[data-empty="true"]::before {
  content: attr(data-placeholder);
  color: #9ca3af; /* muted gray */
  pointer-events: none;
}
</style>

<!-- Alpine runs init() on mount -->
<div class="profile-shell" x-data="profileLinksEditor()" x-init="init()">

  <!-- Avatar -->
  <div class="avatar-wrap">
    <img
      id="avatarPreview"
      alt="Avatar"
      src="{% if profile.profile_image %}{{ profile.profile_image.url }}{% else %}{% static 'images/logo.png' %}{% endif %}"
      class="avatar"
    >
    <input type="file" name="profile_image" accept="image/*" @change="previewAvatar">
  </div>

  <!-- Display name -->
  <h1 style="margin-top: 0.75rem;">
    <input
      class="editable-text"
      type="text"
      name="display_name"
      value="{{ profile.display_name }}"
      placeholder="Your name"
      style="text-align:center;"
      @blur="saveProfile" />
  </h1>

  <!-- Handle -->
  <div class="handle" style="display:flex; justify-content:center; align-items:center; margin-bottom:0.25rem; font-size:0.95rem; color:#6b7280;">
    <span style="font-weight:500; line-height:1;" aria-hidden="true">@</span>
    <input
      class="editable-text"
      type="text"
      name="handle"
      value="{{ profile.handle }}"
      placeholder="username"
      style="text-align:center; width:auto; min-width:6ch; padding:0; margin:0; line-height:1; font:inherit; color:inherit;"
      inputmode="latin" autocomplete="off" autocapitalize="none" spellcheck="false" maxlength="15"
      @input="onHandleInput($event)"
      @blur="saveProfile" />
  </div>

  <!-- Inline validation message for handle -->
  <p x-text="errors.handle" x-show="errors.handle" class="text-red-500 text-sm text-center mt-1" aria-live="polite"></p>

  <!-- Bio -->
  <div
    class="bio editable-area"
    name="bio"
    contenteditable="true"
    data-placeholder="Write your bio here"
    x-ref="bio"
    @input="updateBioPlaceholder"
    @blur="saveProfile"
  >{{ profile.bio|default_if_none:'' }}</div>

  <!-- Links list -->
  <div class="links" id="linksList">
    {% if formset.management_form %}{{ formset.management_form }}{% endif %}
    {% for f in formset %}
      {% with pk=f.instance.pk title_val=f.instance.title url_val=f.instance.url %}
      <div class="link-card" data-id="{{ pk }}">
        <div class="link-guts">
          <input
            class="editable-text link-title"
            type="text"
            value="{{ title_val|default:url_val }}"
            placeholder="Display title"
            data-field="title"
            data-original="{{ title_val|default:url_val }}"
            @blur="onLinkFieldBlur($event)">
          <input
            class="editable-text link-url"
            type="url"
            value="{{ url_val }}"
            placeholder="https://example.com"
            data-field="url"
            data-original="{{ url_val }}"
            @blur="onLinkFieldBlur($event)">
          <small class="muted hidden" data-edited-pill>Edited</small>
        </div>
        <div class="link-actions">
          <button type="button" class="icon-btn" @click="deleteLink($event)" title="Delete" {% if not pk %}disabled{% endif %}>Delete</button>
        </div>
      </div>
      {% endwith %}
    {% empty %}
      <p>No links yet — add your first one below.</p>
    {% endfor %}
  </div>

  <!-- Add new link -->
  <div class="link-card" style="margin-top: 10px;">
    <div class="link-guts">
      <input class="editable-text link-title" type="text" placeholder="Display title" id="newTitle">
      <input class="editable-text link-url" type="url" placeholder="https://example.com" id="newUrl">
    </div>
    <div class="link-actions">
      <button type="button" class="icon-btn" @click="createLink">Add</button>
    </div>
  </div>
</div>

<script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
<script>
function profileLinksEditor() {
  return {
    dragEl: null,
    errors: {},
    pendingSaves: {}, // { [id]: true } while a link save is in-flight

    init() {
      // Run once to set placeholder state for bio on load
      this.updateBioPlaceholder();
      // On first paint, ensure navbar link matches current input value
      const handleEl = document.querySelector('input[name="handle"]');
      if (handleEl) this.updateProfileLinks(handleEl.value.trim());
    },

    /* ---- small util to update all navbar profile links ---- */
    updateProfileLinks(newHandle) {
      if (!newHandle) return;
      const links = Array.from(document.querySelectorAll('#profile-link, a[data-profile-link]'));
      links.forEach((a) => {
        const oldHref = a.getAttribute('href') || a.href || '';
        // Replace only the "/@<handle>" segment (up to next / ? or #)
        const replaced = oldHref.replace(/\/@[^\/?#]*/i, `/@${newHandle}`);
        a.setAttribute('href', replaced === oldHref ? `/@${newHandle}` : replaced);
      });
    },

    updateBioPlaceholder() {
      const el = this.$refs.bio;
      if (!el) return;
      const txt = (el.innerText || '').trim();
      if (txt.length === 0) {
        el.setAttribute('data-empty', 'true');
      } else {
        el.removeAttribute('data-empty');
      }
    },
    
    /* ========== Avatar ========== */
    previewAvatar(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = ev => document.getElementById('avatarPreview').src = ev.target.result;
      reader.readAsDataURL(file);
      this.saveProfile(); // auto-save avatar
    },

    /* ========== Handle input + validation (optimistic link update) ========== */
    onHandleInput(e) {
      // live normalization: lowercase + strip spaces
      const v = e.target.value;
      const normalized = v.toLowerCase().replace(/\s+/g, '');
      if (v !== normalized) e.target.value = normalized;

      // live validation message
      const msg = this.validateHandle(e.target.value);
      this.errors = msg ? { handle: msg } : {};

      // Immediately reflect in navbar (optimistic)
      this.updateProfileLinks(e.target.value.trim());
    },
    validateHandle(value) {
      const handle = (value || '').trim();
      if (handle.length < 3 || handle.length > 15) return 'Handle must be 3–15 characters.';
      if (/\s/.test(handle)) return 'Handle cannot contain spaces.';
      if (!/^[a-z0-9_]+$/.test(handle)) return 'Use lowercase letters, numbers, and underscore only.';
      return null;
    },

    /* ========== Link: save on blur ========== */
    async onLinkFieldBlur(ev) {
      const card = ev.currentTarget.closest('.link-card');
      const id = card?.dataset?.id;
      if (!id) return; // skip "new link" row

      const titleEl = card.querySelector('[data-field="title"]');
      const urlEl   = card.querySelector('[data-field="url"]');
      const titleCur = (titleEl?.value ?? '').trim();
      const urlCur   = (urlEl?.value ?? '').trim();
      const titleOrig = titleEl?.getAttribute('data-original') ?? '';
      const urlOrig   = urlEl?.getAttribute('data-original') ?? '';

      // If no changes, clear pill and bail
      if (titleCur === titleOrig && urlCur === urlOrig) {
        this.markEdited(card, false);
        return;
      }

      // Visual cue while saving
      this.markEdited(card, true);

      await this.saveOneLink(id, { title: titleCur, url: urlCur }, card);
    },

    async saveOneLink(id, { title, url }, card) {
      if (this.pendingSaves[id]) return; // avoid double-saves
      if (!url) { alert('Link URL cannot be empty.'); return; }

      this.pendingSaves[id] = true;
      try {
        const form = new FormData();
        form.append('title', title);
        form.append('url', url);

        const endpoint = "{% url 'link-update' pk=0 %}".replace('/0/', `/${id}/`);
        const res = await fetch(endpoint, {
          method: 'POST',
          headers: { 'X-CSRFToken': getCookie('csrftoken') },
          body: form
        });
        if (!res.ok) throw new Error('Failed to save link');

        // success: update originals and clear pill
        const titleEl = card.querySelector('[data-field="title"]');
        const urlEl   = card.querySelector('[data-field="url"]');
        if (titleEl) titleEl.setAttribute('data-original', (titleEl.value || '').trim());
        if (urlEl)   urlEl.setAttribute('data-original',   (urlEl.value   || '').trim());
        this.markEdited(card, false);
      } catch (e) {
        console.error(e);
        alert('Could not save this link. Please try again.');
        // keep pill visible so user knows it’s still unsaved
      } finally {
        delete this.pendingSaves[id];
      }
    },

    markEdited(card, isEdited) {
      const pill = card.querySelector('[data-edited-pill]');
      if (!pill) return;
      pill.classList.toggle('hidden', !isEdited);
      card.style.boxShadow = isEdited ? '0 0 0 2px rgba(52,211,153,.35)' : '';
    },

    /* ========== Link create/delete ========== */
    async createLink() {
      const title = document.getElementById('newTitle').value.trim();
      const url   = document.getElementById('newUrl').value.trim();
      if (!url) return alert('Enter a URL');
      const form = new FormData();
      form.append('title', title);
      form.append('url', url);
      await fetch("{% url 'link-create' %}", {
        method: 'POST',
        headers: { 'X-CSRFToken': getCookie('csrftoken') },
        body: form
      }).then(() => location.reload()).catch(console.error);
    },
    async deleteLink(ev) {
      const card = ev.currentTarget.closest('.link-card');
      const id = card?.dataset?.id;
      if (!id || !confirm('Delete this link?')) return;
      const endpoint = "{% url 'link-delete' pk=0 %}".replace('/0/', `/${id}/`);
      await fetch(endpoint, {
        method: 'POST',
        headers: { 'X-CSRFToken': getCookie('csrftoken') }
      }).then(() => location.reload()).catch(console.error);
    },

    /* ========== Profile auto-save (name/handle/bio/avatar) ========== */
    async saveProfile() {
      const nameEl = document.querySelector('input[name="display_name"]');
      const handleEl = document.querySelector('input[name="handle"]');
      const bioEl = document.querySelector('.bio');

      const name = (nameEl?.value || '').trim();
      const handleTyped = (handleEl?.value || '').trim();
      const bio = (bioEl?.innerText || '').trim();

      const msg = this.validateHandle(handleTyped);
      if (msg) { this.errors = { handle: msg }; return; }
      this.errors = {};

      // Optimistic: make sure navbar reflects what the user just set on blur
      this.updateProfileLinks(handleTyped);

      try {
        const form = new FormData();
        form.append('display_name', name);
        form.append('handle', handleTyped);
        form.append('bio', bio);
        const fileInput = document.querySelector('input[name="profile_image"]');
        if (fileInput && fileInput.files[0]) form.append('profile_image', fileInput.files[0]);

        const res = await fetch(window.location.href, {
          method: 'POST',
          headers: { 'X-CSRFToken': getCookie('csrftoken') },
          body: form
        });

        // Parse HTML to detect server-side errors (e.g., duplicate handle)
        const html = await res.text();
        const doc = new DOMParser().parseFromString(html, 'text/html');
        const errorEl = doc.querySelector('.errorlist li');

        if (res.ok && !errorEl) {
          this.errors = {};

          // Read the canonical/saved handle from the server-rendered form
          const savedHandleInput = doc.querySelector('input[name="handle"]');
          const savedHandle = (savedHandleInput?.getAttribute('value') || savedHandleInput?.value || handleTyped).trim();

          // Keep the visible input in sync with server-normalized handle
          if (handleEl && savedHandle && handleEl.value !== savedHandle) {
            handleEl.value = savedHandle;
          }

          // Update navbar again with server-accepted handle (authoritative)
          this.updateProfileLinks(savedHandle);

          // Also broadcast for any listeners in base.html (harmless if you keep it)
          window.dispatchEvent(new CustomEvent('profile:saved', { detail: { handle: savedHandle } }));

          console.log('[saveProfile] success, savedHandle =', savedHandle);
        } else {
          this.errors = { handle: errorEl?.innerText || 'Handle already taken or invalid.' };
          console.warn('[saveProfile] server returned errors:', this.errors.handle);
        }
      } catch (err) {
        console.error(err);
        this.errors = { handle: 'Network error while saving. Please try again.' };
      }
    }
  };
}

/* ========== CSRF helper ========== */
function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
      const cookie = cookies[i].trim();
      if (cookie.substring(0, name.length + 1) === (name + '=')) {
        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
        break;
      }
    }
  }
  return cookieValue;
}
</script>
{% endblock %}