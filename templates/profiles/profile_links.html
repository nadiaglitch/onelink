{% extends "base.html" %}
{% load static %}
{% block content %}
<style>
.editable-text {
  border: none; background: transparent; padding: 0; margin: 0; width: 100%;
  font: inherit; color: inherit; outline: none;
}
.editable-text:focus { outline: 2px dashed #9ca3af; outline-offset: 2px; }
.editable-area[contenteditable="true"]:focus { outline: 2px dashed #9ca3af; outline-offset: 2px; }

.profile-shell { max-width: 520px; margin: 0 auto; padding: 2rem 1rem 6rem; text-align: center; }
.avatar-wrap { width: 128px; height: 128px; margin: 0 auto 1rem; position: relative; }
.avatar-wrap img { width: 128px; height: 128px; border-radius: 9999px; object-fit: cover; }
.avatar-wrap input[type="file"] { position: absolute; inset: 0; opacity: 0; cursor: pointer; }

.handle { color: #6b7280; font-size: 0.95rem; }
.bio { color: #374151; margin-top: .5rem; }

.links { display: grid; gap: 10px; margin-top: 1.5rem; }
.link-card {
  border: 1px solid #e5e7eb; border-radius: 12px; padding: 12px 14px;
  display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center;
}
.link-guts { display: grid; gap: 6px; text-align: left; }
.link-title { font-weight: 600; }
.link-url { font-size: .9rem; color: #6b7280; word-break: break-all; }
.link-actions { display: flex; gap: 8px; align-items: center; }
.icon-btn { border: 1px solid #d1d5db; background: white; padding: 6px 10px; border-radius: 8px; cursor: pointer; }
.icon-btn[disabled] { opacity: .5; cursor: not-allowed; }

.toolbar {
  position: sticky; bottom: 0; left: 0; right: 0;
  background: rgba(255,255,255,.8); backdrop-filter: blur(6px);
  border-top: 1px solid #e5e7eb; padding: 10px; display: flex; gap: 10px; justify-content: center;
}

.drag { cursor: grab; user-select: none; font-size: 18px; }
.drag:active { cursor: grabbing; }
.hidden { display: none; }
</style>

<div class="profile-shell" x-data="profileLinksEditor()">

  <!-- Avatar -->
  <div class="avatar-wrap">
    <img id="avatarPreview" src="{{ profile.profile_image.url }}" alt="Avatar">
    <input type="file" name="profile_image" accept="image/*" @change="previewAvatar">
  </div>

  <!-- Display name -->
  <h1 style="margin-top: 0.75rem;">
    <input class="editable-text" type="text" name="display_name" value="{{ profile.display_name }}" placeholder="Your name" style="text-align:center;">
  </h1>

  <!-- Handle (centered, inline, visually matches public page) -->
  <div class="handle"
      style="display:flex; justify-content:center; align-items:center; margin-bottom:0.25rem; font-size:0.95rem; color:#6b7280;">
    <span style="font-weight:500; line-height:1;" aria-hidden="true">@</span><input
      class="editable-text"
      type="text"
      name="handle"
      value="{{ profile.handle }}"
      placeholder="username"
      style="text-align:center; width:auto; min-width:6ch; padding:0; margin:0; line-height:1; font:inherit; color:inherit;">
  </div>

  <!-- Bio -->
  <div class="bio editable-area" name="bio" contenteditable="true">{{ profile.bio }}</div>

  <!-- EXISTING LINKS (from formset) -->
  <div class="links" id="linksList" @dragover.prevent @drop="onDrop">
    {% if formset.management_form %}{{ formset.management_form }}{% endif %}
    {% for f in formset %}
      {# We expect fields: id (hidden), title, url. f.instance is set for existing rows. #}

    {% with pk=f.instance.pk title_val=f.instance.title url_val=f.instance.url %}
    <div class="link-card" draggable="true" data-id="{{ pk }}" @dragstart="onDragStart">
      <div class="link-guts">
        <input
          class="editable-text link-title"
          type="text"
          value="{{ title_val|default:url_val }}"
          placeholder="Display title"
          data-field="title"
          :data-original="undefined"
          data-original="{{ title_val|default:url_val }}"
          @blur="onLinkFieldBlur($event)"
        >
        <input
          class="editable-text link-url"
          type="url"
          value="{{ url_val }}"
          placeholder="https://example.com"
          data-field="url"
          :data-original="undefined"
          data-original="{{ url_val }}"
          @blur="onLinkFieldBlur($event)"
        >
        <small class="muted hidden" data-edited-pill>Edited</small>
      </div>
      <div class="link-actions">
        <button type="button" class="icon-btn drag" title="Drag to reorder">⋮⋮</button>
        <!-- Removed individual Save button -->
        <button type="button" class="icon-btn" @click="deleteLink($event)" title="Delete" {% if not pk %}disabled{% endif %}>Delete</button>
      </div>
    </div>
    {% endwith %}

    {% empty %}
      <p>No links yet — add your first one below.</p>
    {% endfor %}
  </div>

  <!-- Add new link -->
  <div class="link-card" style="margin-top: 10px;">
    <div class="link-guts">
      <input class="editable-text link-title" type="text" placeholder="Display title" id="newTitle">
      <input class="editable-text link-url" type="url" placeholder="https://example.com" id="newUrl">
    </div>
    <div class="link-actions">
      <button type="button" class="icon-btn" @click="createLink">Add</button>
    </div>
  </div>

  <!-- Toolbar -->
  <div class="toolbar">
    <button type="button" class="btn primary"   @click="saveProfile">Save profile</button>
    <button type="button" class="btn secondary" @click="resetLocal">Reset unsaved</button>
  </div>

  
</div>

<script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
<script>
function profileLinksEditor() {
  return {
    dragEl: null,
    // id -> { title: "...", url: "..." } (only fields that changed)
    dirtyLinks: {},

    previewAvatar(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => { document.getElementById('avatarPreview').src = ev.target.result; };
      reader.readAsDataURL(file);
    },

    onDragStart(e) {
      this.dragEl = e.currentTarget;
      e.dataTransfer.effectAllowed = 'move';
    },
    onDrop(e) {
      const list = document.getElementById('linksList');
      const children = [...list.querySelectorAll('.link-card[data-id]')];
      const after = children.find(child => {
        const rect = child.getBoundingClientRect();
        return e.clientY < rect.top + rect.height / 2;
      });
      list.insertBefore(this.dragEl, after || null);
      this.saveOrder();
    },

    async saveOrder() {
      const ids = [...document.querySelectorAll('.link-card[data-id]')]
        .map(el => el.dataset.id)
        .filter(Boolean);
      if (!ids.length) return;
      const url = "{% url 'link-reorder' %}";
      await fetch(url, {
        method: 'POST',
        headers: { 'X-CSRFToken': getCookie('csrftoken'), 'Content-Type': 'application/json' },
        body: JSON.stringify({ ordered_ids: ids })
      }).catch(console.error);
    },

    onLinkFieldBlur(ev) {
      const input = ev.currentTarget;
      const card = input.closest('.link-card');
      const id = card?.dataset?.id;
      if (!id) return;

      const field = input.dataset.field; // "title" | "url"
      const original = input.getAttribute('data-original') ?? '';
      const current  = input.value.trim();

      // Compare; if changed, store in dirty map
      if (current !== original) {
        if (!this.dirtyLinks[id]) this.dirtyLinks[id] = {};
        this.dirtyLinks[id][field] = current;
        this.markEdited(card, true);
      } else {
        // If reverted to original, clean dirty state for that field
        if (this.dirtyLinks[id]) {
          delete this.dirtyLinks[id][field];
          if (!Object.keys(this.dirtyLinks[id]).length) delete this.dirtyLinks[id];
        }
        // If no fields left dirty for this card, clear pill
        if (!this.dirtyLinks[id]) this.markEdited(card, false);
      }
    },

    markEdited(card, isEdited) {
      const pill = card.querySelector('[data-edited-pill]');
      if (!pill) return;
      pill.classList.toggle('hidden', !isEdited);
      // optional: subtle color cue
      card.style.boxShadow = isEdited ? '0 0 0 2px rgba(52,211,153,.35)' : '';
    },

    async createLink() {
      const titleEl = document.getElementById('newTitle');
      const urlEl   = document.getElementById('newUrl');
      const title = (titleEl?.value || '').trim();
      const url   = (urlEl?.value || '').trim();
      if (!url) { alert('Enter a URL'); return; }

      const form = new FormData();
      form.append('title', title);
      form.append('url', url);

      await fetch("{% url 'link-create' %}", {
        method: 'POST',
        headers: { 'X-CSRFToken': getCookie('csrftoken') },
        body: form
      }).then(() => location.reload()).catch(console.error);
    },

    async deleteLink(ev) {
      const card = ev.currentTarget.closest('.link-card');
      const id = card?.dataset?.id;
      if (!id) return;
      if (!confirm('Delete this link?')) return;

      const endpoint = "{% url 'link-delete' pk=0 %}".replace('/0/', `/${id}/`);
      await fetch(endpoint, {
        method: 'POST',
        headers: { 'X-CSRFToken': getCookie('csrftoken') }
      }).then(() => location.reload()).catch(console.error);
    },

    async saveProfile() {
      try {
        // 1) Persist any edited links first (batch by looping existing endpoint)
        const updates = Object.entries(this.dirtyLinks);
        for (const [id, payload] of updates) {
          const form = new FormData();
          // Title & URL: send changed value OR current input value (to be safe)
          const card = document.querySelector(`.link-card[data-id="${id}"]`);
          const titleVal = (payload.title ?? card?.querySelector('[data-field="title"]')?.value ?? '').trim();
          const urlVal   = (payload.url   ?? card?.querySelector('[data-field="url"]')?.value   ?? '').trim();
          if (!urlVal) continue; // don't save empty url

          form.append('title', titleVal);
          form.append('url', urlVal);

          const endpoint = "{% url 'link-update' pk=0 %}".replace('/0/', `/${id}/`);
          const res = await fetch(endpoint, {
            method: 'POST',
            headers: { 'X-CSRFToken': getCookie('csrftoken') },
            body: form
          });
          if (!res.ok) throw new Error('Failed to save a link');
        }

        // 2) Save the profile itself
        const pform = new FormData();
        pform.append('display_name', document.querySelector('input[name="display_name"]').value.trim());
        pform.append('handle', document.querySelector('input[name="handle"]').value.trim());
        pform.append('bio', document.querySelector('.bio').innerText.trim());
        const fileInput = document.querySelector('input[name="profile_image"]');
        if (fileInput && fileInput.files[0]) pform.append('profile_image', fileInput.files[0]);

        const res2 = await fetch('', {
          method: 'POST',
          headers: { 'X-CSRFToken': getCookie('csrftoken') },
          body: pform
        });
        if (!res2.ok) throw new Error('Failed to save profile');

        // 3) On success: reset dirty state & reload to reflect saved originals
        this.dirtyLinks = {};
        location.reload();
      } catch (e) {
        console.error(e);
        alert('Save failed. Please fix any errors and try again.');
      }
    },

    resetLocal() {
      // Revert all edited link inputs back to their original values
      const cards = document.querySelectorAll('.link-card[data-id]');
      cards.forEach(card => {
        card.querySelectorAll('input[data-field]').forEach(input => {
          const original = input.getAttribute('data-original') ?? '';
          input.value = original;
        });
        this.markEdited(card, false);
      });
      this.dirtyLinks = {};
    }
  };
}

function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
      const cookie = cookies[i].trim();
      if (cookie.substring(0, name.length + 1) === (name + '=')) {
        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
        break;
      }
    }
  }
  return cookieValue;
}
</script>

{% endblock %}